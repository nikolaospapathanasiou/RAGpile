import asyncio
import threading
from dataclasses import dataclass

from apscheduler.triggers.cron import CronTrigger
from langchain.chat_models.base import BaseChatModel
from langchain_core.messages import AIMessage
from langchain_core.runnables.config import RunnableConfig
from pydantic import BaseModel

from agent.agent import Agent
from models import Schedule
from tools.base import AsyncBaseTool


class SchedulerCreateInput(BaseModel):
    name: str
    code: str
    crontab: str


@dataclass
class SchedulerCreate:
    next_run_time: float
    id: str


local = threading.local()


def run_job(code: str, user_id: str):
    loop = asyncio.get_event_loop()

    tools: dict[str, AsyncBaseTool] = local.tools
    for tool in tools.values():
        tool.bind_user_id(user_id)

    user = loop.run_until_complete(tools["scheduler_create"].get_user({}))
    agent: Agent = local.agent
    llm: BaseChatModel = local.llm

    def send_message(text: str) -> None:
        loop.run_until_complete(agent.send_message(AIMessage(content=text), user))

    def invoke_llm(text: str) -> str:
        message = llm.invoke(text)
        return str(message.content)

    exec(
        code,
        None,
        {
            "tools": local.tools,
            "user_id": user_id,
            "send_message": send_message,
            "invoke_llm": invoke_llm,
        },
    )


class SchedulerCreateTool(AsyncBaseTool):
    name: str = "scheduler_create"
    description: str = """
        Create a new scheduled job. This job will run the given code based on the crontab.
        Pick a descriptive name for the job.
        The code is python.
        Crontab is folllowing the standard format, for example: 10 10 * * * runs at 10:10 every day
        The job has access to all the tools that are available to you.
        They are available in a python dict in the global scope, so you can access it like:
        `tools["tool_name"]`
        The input is a dict with the keys named as described in the tools.
        For example, if you want to use the tool named "google_search", you can do:
        `result = tools["google_search"].run({"query": "What are the latest news?"})`
        If you want to call a tool without any input, you still need to pass in an empty dict.
        The results are python dataclasses or a list of dataclasses, the attributes can be accessed with the dot notation, for example:
        `result.title`
        `result[0].link`
        If you want to invoke an llm in order to parse some data and create a message for the user you can do:
        `result = invoke_llm("Can you summarize the latest news?" + str(result))`.
        Always use invoke_llm if you are requested to process data and create a message for the user.
        DO NOT use non existing tools.
        DO NOT use result['items'] for the result of a tool, the return value is either a list or a dataclass.
        You can also send message to the user by calling `send_message("message")`
        when you plan to use this, always ask first if this is what the user wants by showing the code and waiting for a confirmation.
    """
    args_schema: type = SchedulerCreateInput

    async def _arun(
        self, name: str, code: str, crontab: str, config: RunnableConfig
    ) -> SchedulerCreate:
        job = self.dependencies.scheduler.add_job(
            name=name,
            func=run_job,
            trigger=CronTrigger.from_crontab(crontab),
            args=[code, self._get_user_id(config)],
        )
        async with self.dependencies.session_factory() as session:
            schedule = Schedule(user_id=self._get_user_id(config), id=job.id)
            session.add(schedule)
            await session.commit()
        return SchedulerCreate(next_run_time=job.next_run_time, id=job.id)
